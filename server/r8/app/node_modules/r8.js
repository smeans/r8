'use strict';
function randomUUID(a){return a?(a^Math.random()*16>>a/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,randomUUID)}

/*
 *  R8 Terms
 *
 *  A R8 package is composed of terms, with different term types
 * providing different functionality.
 */

/** R8 source linter */
class R8Linter {
    static ID_POLICIES = {
        'generic': /^[\w\d_\-]+$/,
        'TitleCase': /^\p{Lu}\p{L}*$/u,
        'camelCase': /^\p{Ll}\p{L}*$/u,
        'snake_case': /^(\p{Ll}|(\p{Ll}[\p{Ll}_]*\p{Ll}))$/u
    };

    static get idPolicies() {
        return Object.keys(R8Linter.ID_POLICIES);
    }

    constructor(idPolicy) {
        this.idPolicy = idPolicy;
    }

    set idPolicy(newIdPolicy) {
        if (!(newIdPolicy in R8Linter.ID_POLICIES)) {
            throw new RangeError(`${newIdPolicy} is not a valid identifier policy: ${R8Linter.idPolicies}`);
        }

        this._idPolicy = newIdPolicy;
    }

    get idPolicy() {
        return this._idPolicy;
    }

    validateIdentifier(identifier) {
        return R8Linter.ID_POLICIES[this.idPolicy].test(identifier);
    }

    getPackageIssues(pkg) {
        const issues = [];

        pkg.undefinedTerms.forEach((term) => {
            issues.push(`term '${term}' is undefined`);
        });

        Object.keys(pkg.terms).forEach((term) => {
            if (!this.validateIdentifier(term)) {
                issues.push(`term name '${term}' does not conform to the ${this.idPolicy} naming policy`);
            }
        });

        return issues;
    }
}

/** R8 term abstract base class */
class R8Term {
    constructor(pkg) {
        if (this.constructor == R8Term) {
            throw new TypeError('abstract class R8Term cannot be instantiated');
        }

        this._package = pkg;
    }

    get package() {
        return this._package;
    }

    get name() {
        return this._package.getTermName(this);
    }

    get termTypeName() {
        return this._package.getTermTypeName(this);
    }

    get value() {
        throw new Error('not implemented');
    }

    set value(newValues) {
        throw new Error('not implemented');
    }

    get dataType() {
        throw new Error('not implemented');
    }

    set dataType(newDataType) {
        throw new Error('not implemented');
    }

    get valueType() {
        return {value: this.value, dataType: this.dataType};
    }

    get description() {
        return this._description;
    }

    set description(newDescription) {
        this._description = newDescription;
    }

    get referencedTerms() {
        return new Set();
    }

    get undefinedTerms() {
        return new Set();
    }

    get json() {
        const out = this._json ? JSON.parse(JSON.stringify(this._json)) : {};
        out.isPublic = !!this.isPublic;
        out.description = this._description;

        return out;
    }

    set json(newJson) {
        this._json = JSON.parse(JSON.stringify(newJson))

        this.isPublic = newJson.isPublic;
        this._description = newJson.description;
    }
}

/** R8 mathematical expression term. */
class R8ExpressionTerm extends R8Term {
    static _lexRules = [
        ['ws', /\s+/],
        ['name', /[a-zA-Z]\w*/],
        ['operator', /[\+\-\*\/%]/],
        ['parenthesis', /[\(\)]/],
        ['error', /./]
    ];

    static _operatorPrecedence = {
        '+': 0,
        '-': 0,
        '*': 1,
        '/': 1,
        '%': 2
    };

    static _operations = {
        '+': (stack) => {
            const l = stack.pop();
            const r = stack.pop();

            return {value: l.value + r.value, dataType: l.dataType};
        },
        '-': (stack) => {
            const l = stack.pop();
            const r = stack.pop();

            return {value: l.value - r.value, dataType: l.dataType};
        },
        '*': (stack) => {
            const l = stack.pop();
            const r = stack.pop();

            return {value: l.value * r.value, dataType: l.dataType};
        },
        '/': (stack) => {
            const l = stack.pop();
            const r = stack.pop();

            return {value: l.value / r.value, dataType: l.dataType};
        },
        '%': (stack) => {
            const l = stack.pop();
            return {value: l.value / 100.0, dataType: l.dataType};
        }
    }

    static _lexRegex = '(?:' + R8ExpressionTerm._lexRules.map(v => '(?<' + v[0] + '>' + v[1].toString().substr(1, v[1].toString().length-2) + ')').join('|') + ')';

    static* tokenizeExpression (expression) {
        const matches = expression.matchAll(R8ExpressionTerm._lexRegex);
        let i;
        while ((i = matches.next()) && !i.done) {
            const match = i.value;

            for (const group in match.groups) {
                if (match.groups[group]) {
                    yield {
                        "type": group,
                        "value": match.groups[group]
                    };
                }
            }
        }
    }

    static parseExpression(expression) {
        const tokenStream = [];
        const outputQueue = [];
        const operatorStack = [];

        function popOperators(o1) {
            while (operatorStack.length > 0) {
                const o2 = operatorStack[operatorStack.length-1];

                if (R8ExpressionTerm._operatorPrecedence[o2.value] >=
                        R8ExpressionTerm._operatorPrecedence[o1.value]) {
                    outputQueue.push(operatorStack.pop());
                } else {
                    break;
                }
            }
        }

        function throwEvalError(message, token) {
            throw message + ': ' + tokenStream.map(t => t.value).join('') + '_' + token.value + '_';
        }

        for (const token of R8ExpressionTerm.tokenizeExpression(expression)) {
            switch (token.type) {
                case 'name': {
                    outputQueue.push(token);
                } break;

                case 'operator': {
                    popOperators(token);

                    operatorStack.push(token);
                } break;

                case 'parenthesis': {
                    if (token.value == '(') {
                        operatorStack.push(token);
                    } else {
                        while (operatorStack.length > 0
                                && operatorStack[operatorStack.length-1].value != '(') {
                            outputQueue.push(operatorStack.pop());
                        }

                        const lastOperator = operatorStack.pop();

                        if (!lastOperator || lastOperator.value != '(') {
                            throwEvalError('mismatched parenthesis', token);
                        }
                    }
                } break;

                case 'error': {
                    throwEvalError('invalid token', token);
                } break;
            }

            tokenStream.push(token);
        }

        while (operatorStack.length > 0) {
            outputQueue.push(operatorStack.pop());
        }

        return outputQueue;
    }

    get value() {
        return this.valueType.value;
    }

    /**
     * Since expression terms must be evaluated, the
     * value property setter is just an alias for
     * the expressionSource property.
     */
    set value(newValue) {
        this.expressionSource = newValue;
    }

    get dataType() {
        return this._dataType;
    }

    set dataType(newDataType) {
        this._dataType = newDataType;
    }

    get valueType() {
        return this._evaluateExpression();
    }

    get expressionSource() {
        return this._expressionSource;
    }

    set expressionSource(newExpressionSource) {
        this._expression = R8ExpressionTerm.parseExpression(newExpressionSource);
        this._expressionSource = newExpressionSource;
    }

    _evaluateExpression() {
        if (!this._expression || this._expression.length == 0) {
            throw `${this.name} term: invalid or missing expression`;
        }

        const stack = [];

        this._expression.forEach(token => {
            switch (token.type) {
                case 'name': {
                    const term = this._package.getTerm(token.value);
                    if (term === undefined) {
                        throw 'undefined term: '  + token.value;
                    }

                    const valueType = term.valueType;

                    if (valueType.value === undefined) {
                        this.package.evalContext && this.package.evalContext.warn(this, `term ${term.name} value is undefined`);
                    }

                    stack.push(valueType);
                } break;

                case 'operator': {
                    stack.push(R8ExpressionTerm._operations[token.value](stack));
                } break;
            }
        });

        if (stack.length == 1) {
            const out = stack.pop();

            return this._dataType !== undefined ? R8Package.castValueType(out, this._dataType) : out;
        } else {
            throw 'error evaluating term: ' + this._expression;
        }
    }

    get referencedTerms() {
        if (!this._expression) {
            return new Set();
        }

        const termSet = new Set();

        this._expression.forEach(token => {
            if (token.type == 'name') {
                const term = this._package.getTerm(token.value);
                if (term) {
                    termSet.add(term);
                }
            }
        });

        return termSet;
    }

    get undefinedTerms() {
        const out = new Set();

        this._expression.forEach(token => {
            if (token.type == 'name'
                    && !this._package.getTerm(token.value)) {
                out.add(token.value);
            }
        });

        return out;
    }

    get json() {
        const out = super.json;

        out.expressionSource = this.expressionSource;
        out.dataType = this._dataType;

        return out;
    }

    set json(newJson) {
        super.json = newJson;

        this.expressionSource = newJson.expressionSource || '';
        this._dataType = newJson.dataType;
    }
}

/** R8 input terms are exposed through the R8 API. */
class R8InputTerm extends R8Term {
    get value() {
        if (!this.package.evalContext) {
            return undefined;
        }

        const value = this.package.evalContext.inputs[this.name];

        if (value === undefined) {
            this.package.evalContext.warn(this, 'value undefined')
        }

        switch (this.dataType) {
            case 'Integer': {
                return parseInt(value);
            }

            case 'Float':
            case 'Currency': {
                return Number(value.replace('$,', ''));
            }
        }

        return value;
    }

    set value(newValue) {
        console.assert(`attempt to set input parameter ${this.name} directly`);
    }

    get dataType() {
        return this._dataType;
    }

    set dataType(newDataType) {
        if (newDataType && R8Package.DATA_TYPES.indexOf(newDataType) < 0) {
            throw new RangeError(`'${newDataType}' is not a valid data type`);
        }

        this._dataType = newDataType;
    }

    get json() {
        const out = super.json;

        out.dataType = this.dataType;

        return out;
    }

    set json(newJson) {
        super.json = newJson;

        this.dataType = newJson.dataType;
    }

    getChoices() {
        if (this.dataType != 'String') {
            return undefined;
        }

        const choices = new Set();
        this.package.getReferencingTerms(this).forEach((term) => {
            if (!(term instanceof R8TableTerm)) {
                return;
            }

            Array.from(term.getChoices(this)).forEach((choice) => choices.add(choice));
        });

        return choices;
    }
}

/** Defines a literal constant value for use in expressions. */
class R8ConstantTerm extends R8Term {
    _value = undefined;

    get value() {
        return this._value;
    }

    set value(newValue) {
        if (newValue !== null && typeof newValue === 'object'
                    && typeof newValue.toString === 'function') {
            newValue = R8Package.castValueType({value: newValue.toString(), dataType: 'String'}, this.dataType).value;
        }

        this._value = newValue
    }

    get dataType() {
        return this._dataType;
    }

    set dataType(newDataType) {
        this._dataType = newDataType;
    }

    get json() {
        const out = super.json;
        out.dataType = this._dataType;
        out.value = this.value;

        return out;
    }

    set json(newJson) {
        super.json = newJson;

        this.dataType = newJson.dataType;
        this.value = newJson.value;
    }
}

/** Provides table lookup functionality. */
class R8TableTerm extends R8Term {
    static KEY_TERM_MATCH_TYPES = ['Exact', 'ClosestLowValue', 'ClosestHighValue'];

    _keyTerms = {}

    get value() {
        const res = this.package.environment.tableProvider.lookupTerm(this);

        const rows = [...res];

        switch (rows.length) {
            case 0: {
                this.package.evalContext && this.package.evalContext.warn(this, `no lookup found: keys ${Array.from(this.keyTermNames).join(', ')}`);

                return undefined;
            }

            case 1: {
                return R8Package.castValueType({value: rows[0]._value, dataType: 'String'}, this.dataType).value;
            }

            default: {
                this.package.evalContext && this.package.evalContext.warn(this, `multiple matching rows: keys ${Array.from(this.keyTermNames).join(', ')}`);

                return undefined;
            }
        }
    }

    get dataType() {
        return this._dataType;
    }

    set dataType(newDataType) {
        this._dataType = newDataType;
    }

    addKeyTerm(termName) {
        if (!this.keyTerms[termName]) {
            this.keyTerms[termName] = {};
        }
    }

    deleteKeyTerm(termName) {
        if (termName in this.keyTerms) {
            console.assert(delete this.keyTerms[termName]);
        }
    }

    getKeyTermMatchType(termName) {
        return this._keyTerms[termName] && (this._keyTerms[termName].matchType
                    || R8TableTerm.KEY_TERM_MATCH_TYPES[0]);
    }

    setKeyTermMatchType(termName, matchType) {
        return this._keyTerms && !!(this._keyTerms[termName].matchType = matchType);
    }

    set value(newValue) {
        throw new Error('table term values are read-only');
    }

    get table() {
        return this.package.environment.tableProvider.getTermTable(this);
    }

    get keyTerms() {
        return this._keyTerms;
    }

    get keyTermNames() {
        return new Set(Object.keys(this._keyTerms));
    }

    get json() {
        const out = super.json;

        out.dataType = this._dataType;
        out.keyTerms = this._keyTerms;

        return out;
    }

    set json(newJson) {
        super.json = newJson;

        this._keyTerms = newJson.keyTerms || {};
        this._dataType = newJson.dataType;
    }

    get referencedTerms() {
        return new Set(Array.from(this.keyTermNames).map(key => this.package.getTerm(key)).filter(term => !!term));
    }

    get undefinedTerms() {
        return new Set(Array.from(this.keyTermNames).filter(termName => !this.package.getTerm(termName)));
    }

    getChoices(keyTerm) {
        if (keyTerm instanceof R8Term) {
            keyTerm = keyTerm.name;
        }

        return [...this.table.getChoices(keyTerm)].map(row => row[keyTerm]);
    }
}

/** Calls external services. */
class R8IntegrationTerm extends R8Term {

}

/** Execution environment-specific terms. */
class R8EnvironmentTerm extends R8Term  {

}

class R8EvalContext {
    constructor(inputs) {
        this._inputs = inputs;
        this._termValues = {};
        this.log = [];
    }

    get inputs() {
        return this._inputs;
    }

    get value() {
        return this._value;
    }

    get termValues() {
        return this._termValues;
    }

    set value(newValue) {
        this._value = newValue;
    }

    setTermValue(term, value) {
        if (term instanceof R8Term) {
            term = term.name;
        }

        if (term in this._termValues) {
            throw `circular reference detected evaluating ${term}`;
        }

        this._termValues[term] = value;
    }

    warn(term, message) {
        this.log.push({
            level: 'warn',
            term: term,
            message: message
        });
    }

    error(term, message) {
        this.log.push({
            level: 'error',
            term: term,
            message: message
        });
    }
}

const TERM_TYPES = {
    'expression': R8ExpressionTerm,
    'input': R8InputTerm,
    'constant': R8ConstantTerm,
    'table': R8TableTerm,
    'integration': R8IntegrationTerm,
    'environment': R8EnvironmentTerm
};

const TERM_TYPE_NAMES = {};
Object.keys(TERM_TYPES).forEach(name => {
    TERM_TYPE_NAMES[TERM_TYPES[name]] = name;
});

class R8Package {
    static DATA_TYPES = ['String', 'Integer', 'Currency', 'Float',
            'Date', 'DateTime'];

    static castValueType(valueType, dataType) {
        const out = {value: valueType.value, dataType: dataType};

        switch (dataType) {
            case 'String': {
                out.value = valueType.value.toString();
            } break;

            case 'Integer': {
                out.value = typeof(valueType.value) == 'string' ?
                    parseInt(valueType.value) : Math.floor(valueType.value);
            } break;

            case 'Currency': {
                out.value = Math.floor(parseFloat(valueType.value) * 100.0)/100;
            } break;

            case 'Float': {
                out.value = parseFloat(valueType.value);
            } break;

            // !!!TBD!!! look at dates/datetimes
        }

        return out;
    }

    static fromJson(json) {
        const pkg = new R8Package();

        pkg._json = JSON.parse(JSON.stringify(json));
        pkg.effectiveDate = json.effectiveDate;
        pkg.packageId = json.packageId;
        pkg.productId = json.productId;

        pkg._terms = {};

        for (const name in json.terms) {
            const termWrapper = json.terms[name];
            const termJson = termWrapper.data;
            const term = new TERM_TYPES[termWrapper.type](pkg);

            term.json = termJson;

            pkg.defineTerm(name, term);
        }

        return pkg;
    }

    _terms = {};

    constructor(linter) {
        this.packageId = randomUUID();
        this._linter = linter || new R8Linter('generic');
    }

    get environment() {
        return this._environment;
    }

    set environment(newEnvironment) {
        this._environment = newEnvironment;
    }

    get id() {
        return this.packageId;
    }

    get json() {
        const out = this._json ? JSON.parse(JSON.stringify(this._json)) : {};
        out.effectiveDate = this.effectiveDate;
        out.packageId = this.packageId;
        out.terms = {};

        Object.keys(this._terms).forEach(name => {
            const term = this._terms[name];

            out.terms[name] = {
                "name": name,
                "type": TERM_TYPE_NAMES[term.constructor],
                "data": term.json
            };
        });

        return out;
    }

    get terms() {
        return this._terms;
    }

    get undefinedTerms() {
        const out = new Set();

        for (const term of Object.values(this._terms)) {
            Array.from(term.undefinedTerms).forEach(ut => out.add(ut));
        }

        return out;
    }

    get linter() {
        return this._linter;
    }

    createTerm(type, value=undefined) {
        if (!(type in TERM_TYPES)) {
            throw 'unknown term type "' + type + '"';
        }

        const term = new TERM_TYPES[type](this);
        if (value !== undefined) {
            term.value = value;
        }

        return term;
    }

    getTerm(term) {
        return this._terms[term];
    }

    deleteTerm(term) {
        if (term in this._terms) {
            delete this._terms[term];

            return true;
        }

        return false;
    }

    defineTerm(name, term) {
        if (term === undefined || !(term instanceof R8Term)) {
            throw 'invalid term definition: ' + term;
        }

        if (!this.linter.validateIdentifier(name)) {
            throw RangeError(`identifier '${name}' does not conform to the organization's ${this.linter.idPolicy} naming convention`);
        }

        this._terms[name] = term;
    }

    getTermName(term) {
        try {
            return Object.keys(this._terms)[Object.values(this._terms).indexOf(term)];
        } catch {
            return undefined;
        }
    }

    getTermTypeName(term) {
        return TERM_TYPE_NAMES[term.constructor];
    }

    getReferencedTerms(term) {
        return term.referencedTerms;
    }

    getReferencingTerms(term) {
        return new Set(Array.from(Object.values(this._terms)).filter(t => t.referencedTerms.has(term)));
    }

    getRequiredInputs(term) {
        const visited = new Set();
        const inputs = new Set();

        const visitReferencedTerms = (t) => {
            if (visited.has(t)) {
                return;
            }

            visited.add(t);

            if (t instanceof R8InputTerm) {
                inputs.add(t);
            }

            Array.from(this.getReferencedTerms(t)).forEach((rt) => visitReferencedTerms(rt));
        }

        visitReferencedTerms(term);

        return inputs;
    }

    evalTerm(term, inputs) {
        console.assert(!this.evalContext, 're-entrancy issue in R8Package evalTerm()');

        const ec = new R8EvalContext(inputs);
        this.evalContext = ec;
        ec.value = term.value;
        this.evalContext = undefined;

        return ec;
    }
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        R8Linter,
        R8Package
    }
}
