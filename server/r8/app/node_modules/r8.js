'use strict';
function randomUUID(a){return a?(a^Math.random()*16>>a/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,randomUUID)}

/*
 *  R8 Terms
 *
 *  A R8 package is composed of terms, with different term types
 * providing different functionality.
 */

/** R8 term abstract base class */
class R8Term {
    constructor(pkg) {
        if (this.constructor == R8Term) {
            throw new TypeError('abstract class R8Term cannot be instantiated');
        }

        this._package = pkg;
    }

    get package() {
        return this._package;
    }

    get name() {
        return this._package.getTermName(this);
    }

    get termTypeName() {
        return this._package.getTermTypeName(this);
    }

    get value() {
        throw 'not implemented';
    }

    set value(newValues) {
        throw 'not implemented';
    }

    get dataType() {
        throw 'not implemented';
    }

    set dataType(newDataType) {
        throw 'not implemented';
    }

    get description() {
        return this._description;
    }

    set description(newDescription) {
        this._description = newDescription;
    }

    get referencedTerms() {
        console.log('in referencedTerms prop');
        return new Set();
    }

    get json() {
        const out = this._json ? JSON.parse(JSON.stringify(this._json)) : {};
        out.isPublic = !!this.isPublic;
        out.description = this._description;

        return out;
    }

    set json(newJson) {
        this._json = JSON.parse(JSON.stringify(newJson))

        this.isPublic = newJson.isPublic;
        this._description = newJson.description;
    }
}

/** R8 mathematical expression term. */
class R8ExpressionTerm extends R8Term {
    static _lexRules = [
        ['ws', /\s+/],
        ['name', /[a-zA-Z]\w*/],
        ['operator', /[\+\-\*\/%]/],
        ['parenthesis', /[\(\)]/],
        ['error', /./]
    ];

    static _operatorPrecedence = {
        '+': 0,
        '-': 0,
        '*': 1,
        '/': 1,
        '%': 2
    };

    static _lexRegex = '(?:' + R8ExpressionTerm._lexRules.map(v => '(?<' + v[0] + '>' + v[1].toString().substr(1, v[1].toString().length-2) + ')').join('|') + ')';

    static* tokenizeExpression (expression) {
        const matches = expression.matchAll(R8ExpressionTerm._lexRegex);
        let i;
        while ((i = matches.next()) && !i.done) {
            const match = i.value;

            for (const group in match.groups) {
                if (match.groups[group]) {
                    yield {
                        "type": group,
                        "value": match.groups[group]
                    };
                }
            }
        }
    }

    static parseExpression(expression) {
        const tokenStream = [];
        const outputQueue = [];
        const operatorStack = [];

        function popOperators(o1) {
            while (operatorStack.length > 0) {
                const o2 = operatorStack[operatorStack.length-1];

                if (R8ExpressionTerm._operatorPrecedence[o2.value] >=
                        R8ExpressionTerm._operatorPrecedence[o1.value]) {
                    outputQueue.push(operatorStack.pop());
                } else {
                    break;
                }
            }
        }

        function throwEvalError(message, token) {
            throw message + ': ' + tokenStream.map(t => t.value).join('') + '_' + token.value + '_';
        }

        for (const token of R8ExpressionTerm.tokenizeExpression(expression)) {
            switch (token.type) {
                case 'name': {
                    outputQueue.push(token);
                } break;

                case 'operator': {
                    popOperators(token);

                    operatorStack.push(token);
                } break;

                case 'parenthesis': {
                    if (token.value == '(') {
                        operatorStack.push(token);
                    } else {
                        while (operatorStack.length > 0
                                && operatorStack[operatorStack.length-1].value != '(') {
                            outputQueue.push(operatorStack.pop());
                        }

                        const lastOperator = operatorStack.pop();

                        if (!lastOperator || lastOperator.value != '(') {
                            throwEvalError('mismatched parenthesis', token);
                        }
                    }
                } break;

                case 'error': {
                    throwEvalError('invalid token', token);
                } break;
            }

            tokenStream.push(token);
        }

        while (operatorStack.length > 0) {
            outputQueue.push(operatorStack.pop());
        }

        return outputQueue;
    }

    get value() {
        return this._evaluateExpression();
    }

    /**
     * Since expression terms must be evaluated, the
     * value property setter is just an alias for
     * the expressionSource property.
     */
    set value(newValue) {
        this.expressionSource = newValue;
    }

    get expressionSource() {
        return this._expressionSource;
    }

    set expressionSource(newExpressionSource) {
        this._expression = R8ExpressionTerm.parseExpression(newExpressionSource);
        this._expressionSource = newExpressionSource;
    }

    _evaluateExpression() {
        if (!this._expression) {
            throw 'invalid or missing expression';
        }

        const stack = [];

        this._expression.forEach(token => {
            switch (token.type) {
                case 'name': {
                    const term = this._package.getTerm(token.value);
                    if (term === undefined) {
                        throw 'undefined term: '  + token.value;
                    }

                    stack.push(term.value);
                } break;

                case 'operator': {
                    switch (token.value) {
                        case '+': {
                            stack.push(stack.pop() + stack.pop());
                        } break;

                        case '-': {
                            stack.push(stack.pop() + stack.pop());
                        } break;

                        case '*': {
                            stack.push(stack.pop() * stack.pop());
                        } break;

                        case '/': {
                            stack.push(stack.pop() / stack.pop());
                        } break;

                        case '%': {
                            stack.push(stack.pop()/100.0);
                        } break;
                    }
                } break;
            }
        });

        if (stack.length == 1) {
            return stack.pop();
        } else {
            throw 'error evaluating term: ' + this._expression;
        }
    }

    get referencedTerms() {
        if (!this._expression) {
            return new Set();
        }

        const termSet = new Set();

        this._expression.forEach(token => {
            if (token.type == 'name') {
                const term = this._package.getTerm(token.value);
                if (term) {
                    termSet.add(term);
                }
            }
        });

        return termSet;
    }

    get json() {
        const out = super.json;

        out.expressionSource = this.expressionSource;

        return out;
    }

    set json(newJson) {
        super.json = newJson;

        this.expressionSource = newJson.expressionSource || '';
    }
}

/** R8 input terms are exposed through the R8 API. */
class R8InputTerm extends R8Term {
    _value = undefined;

    get value() {
        return this._value;
    }

    set value(newValue) {
        this._value = newValue;
    }

    get dataType() {
        return this._dataType;
    }

    set dataType(newDataType) {
        if (newDataType && R8Package.DATA_TYPES.indexOf(newDataType) < 0) {
            throw new RangeError(`'${newDataType}' is not a valid data type`);
        }

        this._dataType = newDataType;
    }

    get json() {
        const out = super.json;

        out.dataType = this.dataType;

        return out;
    }

    set json(newJson) {
        super.json = newJson;

        this.dataType = newJson.dataType;
    }
}

/** Defines a literal constant value for use in expressions. */
class R8ConstantTerm extends R8Term {
    _value = undefined;

    get value() {
        return this._value;
    }

    set value(newValue) {
        this._value = newValue;
    }

    get json() {
        const out = super.json;
        out.value = this.value;

        return out;
    }

    set json(newJson) {
        super.json = newJson;

        this.value = newJson.value;
    }
}

/** Provides table lookup functionality. */
class R8TableTerm extends R8Term {
    _keyTermNames = new Set();

    get value() {
        return this.package.environment.tableProvider.lookupTerm(this);
    }

    set value(newValue) {
        throw new Error('table term values are read-only');
    }

    get table() {
        return this.package.environment.tableProvider.getTermTable(this);
    }

    get keyTermNames() {
        return this._keyTermNames;
    }

    get json() {
        const out = super.json;

        out.keyTermNames = Array.from(this._keyTermNames);

        return out;
    }

    set json(newJson) {
        super.json = newJson;

        this._keyTermNames = new Set(newJson.keyTermNames || []);
    }

    get referencedTerms() {
        return new Set(Array.from(this.keyTermNames).map(key => this.package.getTerm(key)).filter(term => !!term));
    }
}

/** Calls external services. */
class R8IntegrationTerm extends R8Term {

}

/** Execution environment-specific terms. */
class R8EnvironmentTerm extends R8Term  {

}

const TERM_TYPES = {
    'expression': R8ExpressionTerm,
    'input': R8InputTerm,
    'constant': R8ConstantTerm,
    'table': R8TableTerm,
    'integration': R8IntegrationTerm,
    'environment': R8EnvironmentTerm
};

const TERM_TYPE_NAMES = {};
Object.keys(TERM_TYPES).forEach(name => {
    TERM_TYPE_NAMES[TERM_TYPES[name]] = name;
});

class R8Package {
    static DATA_TYPES = ['String', 'Integer', 'Currency', 'Percentage',
            'Decimal', 'Date', 'DateTime'];

    static fromJson(json) {
        const pkg = new R8Package();

        pkg._json = JSON.parse(JSON.stringify(json));
        pkg._id = json._id;
        pkg.packageName = json.packageName;

        pkg._terms = {};

        for (const name in json.terms) {
            const termWrapper = json.terms[name];
            const termJson = termWrapper.data;
            const term = new TERM_TYPES[termWrapper.type](pkg);

            term.json = termJson;

            pkg.defineTerm(name, term);
        }

        return pkg;
    }

    _terms = {};

    constructor() {
        this._id = randomUUID();
    }

    get environment() {
        return this._environment;
    }

    set environment(newEnvironment) {
        this._environment = newEnvironment;
    }

    get id() {
        return this._id;
    }

    get json() {
        const out = this._json ? JSON.parse(JSON.stringify(this._json)) : {};
        out._id = this._id;
        out.packageName = this.packageName;
        out.terms = {};

        Object.keys(this._terms).forEach(name => {
            const term = this._terms[name];

            out.terms[name] = {
                "name": name,
                "type": TERM_TYPE_NAMES[term.constructor],
                "data": term.json
            };
        });

        return out;
    }

    get terms() {
        return this._terms;
    }

    createTerm(type, value=undefined) {
        if (!(type in TERM_TYPES)) {
            throw 'unknown term type "' + type + '"';
        }

        const term = new TERM_TYPES[type](this);
        if (value !== undefined) {
            term.value = value;
        }

        return term;
    }

    getTerm(term) {
        return this._terms[term];
    }

    deleteTerm(term) {
        if (term in this._terms) {
            delete this._terms[term];

            return true;
        }

        return false;
    }

    defineTerm(name, term) {
        if (term === undefined || !(term instanceof R8Term)) {
            throw 'invalid term definition: ' + term;
        }

        if (!/^[\w\d_\-]+$/.test(name)) {
            // !!!TBD!!! add an organization setting for identifier naming
            // and enforce it here
            throw RangeError('term name must be a valid identifier')
        }

        this._terms[name] = term;
    }

    getTermName(term) {
        try {
            return Object.keys(this._terms)[Object.values(this._terms).indexOf(term)];
        } catch {
            return undefined;
        }
    }

    getTermTypeName(term) {
        return TERM_TYPE_NAMES[term.constructor];
    }

    getReferencedTerms(term) {
        console.log('getting referenced terms');
        return term.referencedTerms;
    }

    getReferencingTerms(term) {
        return new Set(Array.from(Object.values(this._terms)).filter(t => t.referencedTerms.has(term)));
    }
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        R8Package
    }
}
