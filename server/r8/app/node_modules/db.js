'use strict';

const crypto = require('crypto');
const {MongoClient, ObjectId } = require('mongodb');
const gravatar = require('gravatar');

const log = require('log');
const config = require('config');
const emojis = require('emojis');
const { wsMap } = require('notify');
const { R8Package } = require('r8');
const { R8NodeEnvironment } = require('r8server');

const client = new MongoClient(config.mongodb.url);
client.connect();

const camo = require('camo');
camo.connect(config.mongodb.url);

class SecurityException extends Error {}

class R8Document extends camo.Document {
    static collectionName() {
        return 'r8';
    }

    static async findById(id) {
        const query = {_id: `${this.name}:${id}`};
        return await await this.findOne(query);
    }

    constructor() {
        super();

        this.objectType = {
            type: String,
            default: this.constructor.name
        };
        this.createDateTime = {
            type: Date,
            default: () => new Date()
        };
    }

    get id() {
        return this._id.split(':')[1];
    }

    set id(newId) {
        this._id = `${this.constructor.name}:${newId}`;
    }
}

class Organization extends R8Document {
    static ENVIRONMENTS = ['dev', 'test', 'prod'];
    static ID_POLICIES = {
        'TitleCase': /^\p{Lu}\p{L}*$/u,
        'camelCase': /^\p{Ll}\p{L}*$/u,
        'snake_case': /^(\p{Ll}|(\p{Ll}[\p{Ll}_]*\p{Ll}))$/u
    };

    static async findByApiToken(token) {
        const query = {[`apiTokens.${token}`]: {"$exists": true}};
        const organization = await await this.findOne(query);
        if (organization) {
            organization.currentEnvironment = organization.apiTokens[token].environment;
        }

        return organization;
    }

    constructor() {
        super();

        this._schema._id = { type: String };
        this.name = String;
        this.idPolicy = {
            type: String,
            default: 'TitleCase',
            choices: Object.keys(Organization.ID_POLICIES)
        }
        this.apiTokens = Object;
    }

    get currentEnvironment() {
        if (!this._currentEnvironment) {
            throw Error('currentEnvironment must be set')
        }
        return this._currentEnvironment;
    }

    set currentEnvironment(newEnvironment) {
        if (Organization.ENVIRONMENTS.indexOf(newEnvironment) < 0) {
            throw RangeError(`'${newEnvironment}' is not a valid environment (${Organization.ENVIRONMENTS.join(', ')})`);
        }

        this._currentEnvironment = newEnvironment;
        this._currentEnvironmentObject = null;
    }

    get currentEnvironmentObject() {
        if (!this._currentEnvironmentObject) {
            this._currentEnvironmentObject = new R8NodeEnvironment(this);
        }

        return this._currentEnvironmentObject;
    }

    get collection() {
        return client.db('r8').collection(`org-${this.id}-${this.currentEnvironment}`);
    }

    async getProductList() {
        const products = await this.constructor.find({objectType: 'Product', organization: this._id,
                archiveTs: {$exists: false}});

        const out = [];
        for await (const product of products) {
            out.push({
                _id: product._id,
                productName: product.name,
                description: product.description,
                tags: product.tags
            });
        }

        return out;
    }

    async getPackageList() {
        const packages = this.collection.find({objectType: 'Package', archiveTs: {$exists: false}});

        const out = {};
        for await (const pkg of packages) {
            out[pkg.packageName] = {
                _id: pkg._id,
                packageId: pkg.packageId,
                packageName: pkg.packageName
            };
        }

        return out;
    }

    async createProduct(productName, description, tags) {
        if (!/^[\w\d\-]+$/.test(productName)) {
            throw RangeError('invalid product name');
        }

        const product = Product.create({
            name: productName,
            organization: this,
            description: description,
            tags: tags,
            objectType: 'Product'
        });

        product.id = crypto.randomUUID();

        product.save();

        return product;
    }

    async createPackage(product, packageName) {
        if (!/^[\w\d\-]+$/.test(packageName)) {
            throw RangeError('invalid package name');
        }

        const pkg = R8Package.fromJson({
            packageName: packageName,
            productId: product.id,
            packageId: crypto.randomUUID(),
            objectType: 'Package',
            terms: {}
        });

        this.savePackage(pkg);

        pkg.environment = this.currentEnvironmentObject;

        return pkg;
    }

    async _getPackageDoc(packageId) {
        try {
            return this.collection.findOne({packageId: packageId, archiveTs: {$exists: false}});
        } catch {
            return this.collection.findOne({packageName: packageId});
        }
    }

    async getPackage(packageId) {
        const doc = await this._getPackageDoc(packageId);

        if (!doc) {
            return null;
        }

        const pkg = R8Package.fromJson(doc);
        pkg.environment = this.currentEnvironmentObject;

        return pkg;
    }

    async savePackage(pkg, versionInfo) {
        console.log('saving package', pkg.packageId, pkg.packageName);
        const now = new Date();

        const doc = await this._getPackageDoc(pkg.packageId);

        if (doc) {
            console.log('archiving package version', doc._id);

            await this.collection.updateOne({_id: doc._id}, {$set: {archiveTs: now}});
        }

        const json = pkg.json;
        if (versionInfo !== undefined) {
            versionInfo.saveTs = now;
            json.versionInfo = versionInfo;
        }

        delete json._id;

        return await this.collection.insertOne(json);
    }

    validateIdentifier(identifier) {
        return Organization.ID_POLICIES[this.idPolicy].test(identifier);
    }

    issueApiToken(issueTo, environment) {
        if (Organization.ENVIRONMENTS.indexOf(environment) < 0) {
            throw RangeError(`'${environment}' is not a valid environment (${Organization.ENVIRONMENTS.join(', ')})`);
        }

        if (!this.apiTokens) {
            this.apiTokens = {};
        }

        const token = crypto.randomUUID();
        this.apiTokens[token] = {
            issuedTo: issueTo,
            environment: environment
        };

        return token;
    }

    validateApiToken(token, environment) {
        environment = environment || this.currentEnvironment;

        return this.apiTokens[token] && this.apiTokens[token].environment == environment;
    }

    revokeApiToken(token) {
        delete this.apiTokens[token];
    }

    async getChangeLog() {
        const cursor = this.collection.find({'objectType': 'Package'}, {projection: {'packageName': 1, 'versionInfo': 1}})
                .sort({'versionInfo.saveTs': -1});

        let doc;
        const log = [];
        while (doc = await cursor.next()) {
            Object.assign(doc, doc.versionInfo);
            doc.versionId = doc._id;
            delete doc._id;
            delete doc.versionInfo;

            log.push(doc);
        }

        return log;
    }

    async deploy(deployInfo, pkg) {
        console.assert(Organization.ENVIRONMENTS.indexOf(this.currentEnvironment) < Organization.ENVIRONMENTS.length-1);
        const nextEnv = Organization.ENVIRONMENTS[Organization.ENVIRONMENTS.indexOf(this.currentEnvironment)+1];

        console.debug(`deploying ${pkg.name} from ${this.currentEnvironment} to ${nextEnv}`);

        Object.assign(deployInfo, {
            objectType: "DeployInfo",
            deployTs: new Date(),
            packageId: pkg.id,
            packageName: pkg.name
        });

        await this.collection.insertOne(deployInfo);

        console.log(deployInfo);
    }
}

class Product extends R8Document {
    constructor() {
        super();

        this._schema._id = { type: String };
        this.name = String;
        this.organization = Organization;
        this.description = String;
        this.tags = String;
    }
}

class LoginSession extends R8Document {
    constructor() {
        super();

        this._schema._id = { type: String };
        this.user = {
            type: User,
            required: true
        };
        this.confirmSecret = {
            type: String,
            default: crypto.randomUUID
        };
        this.confirmMnemonic = {
            type: String,
            default: () => emojis.random(3)
        };
        this.confirmDateTime = Date;
    }

    get valid() {
        return !!this.confirmDateTime;
    }

    async confirmLogin(confirmSecret) {
        if (this.confirmSecret == confirmSecret) {
            this.confirmDateTime = new Date();
            await this.save();
        }

        return this.valid;
    }
}

class User extends R8Document {
    static MAX_LOGIN_SESSIONS = 5;

    static normalizeEmail(email) {
        return email.trim().toLowerCase();
    }

    constructor() {
        super();

        this._schema._id = { type: String };
        this.organization = Organization;
        this.email = String;
        this.loginSessions = [String];
    }

    get name() {
        return this.email.split('@')[0];
    }

    get defaultEnvironment() {
        // !!!TBD!!! after we implement roles, etc. we can infer this
        return 'dev';
    }

    async getProductList() {
        return this.organization.getProductList();
    }

    async getPackageList() {
        return this.organization.getPackageList();
    }

    async preSave() {
        if (this._id === undefined) {
            this.id = User.normalizeEmail(this.email);
        }

        if (this.organization === undefined) {
            this.organization = Organization.create({
                name: `(${this.email})`
            });
            this.organization.id = crypto.randomUUID();
            await this.organization.save();
        }

        if (this.loginSessions.length > User.MAX_LOGIN_SESSIONS) {
            log.warn(`user ${this.id} exceeded ${User.MAX_LOGIN_SESSIONS} logins (${this.loginSessions.length})`);
            while (this.loginSessions.length > User.MAX_LOGIN_SESSIONS) {
                const sessionId = this.loginSessions.shift();
                log.warn(`user ${this.id}: deleting session: ${sessionId}`);

                var session = await LoginSession.findById(sessionId);
                session.delete();
            }
        }
    }

    async initiateLogin(sessionId) {
        let session = await LoginSession.findById(sessionId);

        if (session) {
            log.warn('intiateLogin: session exists', sessionId);

            if  (session.user._id != this._id) {
                log.debug('LoginSession', session);
                throw new SecurityException(`attempt to initiate login for existing user ${session.user.id} session: ${sessionId} by ${this.id}`);
            } else {
                return session;
            }
        }

        if (this.loginSessions.indexOf(sessionId) >= 0) {
            session = await LoginSession.findById(sessionId);

            if (session) {
                return session;
            }
        }

        session = LoginSession.create({
            user: this
        });

        session.id = sessionId;
        await session.save();

        log.debug('saved session', session);

        log.debug('loginSessions', this.loginSessions)

        if (this.loginSessions.indexOf(session.id) < 0) {
            log.debug('adding new session');
            this.loginSessions.push(session.id);

            await this.save();
        }

        return session;
    }

    async cancelLogin(loginSessionId) {
        const loginSession = await LoginSession.findById(loginSessionId);
        loginSession && await loginSession.delete();

        this.loginSessions = this.loginSessions.filter(sid => sid != loginSessionId);

        const ws = wsMap.get(loginSessionId);
        if (ws) {
            ws.close();

            wsMap.delete(loginSessionId);
        }

        return await this.save()
    }
}

module.exports = {
    client: client,
    r8: client.db('r8'),
    collection: (name) => client.db('r8').collection(name),
    Organization: Organization,
    Product: Product,
    User: User,
    LoginSession, LoginSession
}
