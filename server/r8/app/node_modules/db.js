'use strict';

const crypto = require('crypto');
const {MongoClient, ObjectId } = require('mongodb');
const gravatar = require('gravatar');

const log = require('log');
const config = require('config');
const emojis = require('emojis');
const { wsMap } = require('notify');
const { R8Package } = require('r8');
const { R8NodeEnvironment } = require('r8server');

const client = new MongoClient(config.mongodb.url);
client.connect();

const camo = require('camo');
camo.connect(config.mongodb.url);

class SecurityException extends Error {}

class R8Document extends camo.Document {
    static collectionName() {
        return 'r8';
    }

    static async findById(id) {
        const query = {_id: `${this.name}:${id}`};
        return await await this.findOne(query);
    }

    constructor() {
        super();

        this.objectType = {
            type: String,
            default: this.constructor.name
        };
        this.createDateTime = {
            type: Date,
            default: () => new Date()
        };
    }

    get id() {
        return this._id.split(':')[1];
    }

    set id(newId) {
        this._id = `${this.constructor.name}:${newId}`;
    }
}

class Organization extends R8Document {
    static ENVIRONMENTS = ['development', 'staging', 'production'];
    static ID_POLICIES = {
        'TitleCase': /^\p{Lu}\p{L}*$/u,
        'camelCase': /^\p{Ll}\p{L}*$/u,
        'snake_case': /^(\p{Ll}|(\p{Ll}[\p{Ll}_]*\p{Ll}))$/u
    };

    static async findByApiToken(token) {
        const query = {[`apiTokens.${token}`]: {"$exists": true}};
        const organization = await await this.findOne(query);
        if (organization) {
            organization.currentEnvironment = organization.apiTokens[token].environment;
        }

        return organization;
    }

    constructor() {
        super();

        this._schema._id = { type: String };
        this.name = String;
        this.idPolicy = {
            type: String,
            default: 'TitleCase',
            choices: Object.keys(Organization.ID_POLICIES)
        }
        this.apiTokens = Object;
    }

    get environments() {
        return Organization.ENVIRONMENTS;
    }

    get currentEnvironment() {
        if (!this._currentEnvironment) {
            throw Error('currentEnvironment must be set')
        }
        return this._currentEnvironment;
    }

    set currentEnvironment(newEnvironment) {
        if (this.environments.indexOf(newEnvironment) < 0) {
            throw RangeError(`'${newEnvironment}' is not a valid environment (${this.environments.join(', ')})`);
        }

        this._currentEnvironment = newEnvironment;
        this._currentEnvironmentObject = null;
    }

    get currentEnvironmentObject() {
        if (!this._currentEnvironmentObject) {
            this._currentEnvironmentObject = new R8NodeEnvironment(this);
        }

        return this._currentEnvironmentObject;
    }

    get collection() {
        return client.db('r8').collection(`org-${this.id}-${this.currentEnvironment}`);
    }

    get validStateCodes() {
        return config.state_codes;
    }

    async getProductList() {
        const products = await Product.find({objectType: 'Product', organization: this._id,
                archiveTs: {$exists: false}});

        const out = [];
        for await (const product of products) {
            out.push({
                id: product._id.split(':')[1],
                productName: product.name,
                description: product.description,
                states: product.states
            });
        }

        return out;
    }

    async getPackageList(productId) {
        const package_docs = this.collection.find({objectType: 'Package',
            productId: productId,
            archiveTs: {$exists: false}
        });

        const out = [];
        for await (const doc of package_docs) {
            const pkg = R8Package.fromJson(doc);

            out.push({
                _id: doc._id,
                productId: doc.productId,
                packageId: doc.packageId,
                versionInfo: doc.versionInfo,
                undefinedTerms: pkg.undefinedTerms,
                effectiveDate: doc.effectiveDate,
                status: await this.getPackageStatus(doc.packageId)
            });
        }

        return out;
    }

    async getPackageLists(productId) {
        const lists = {};
        const currentEnv = this.currentEnvironment;

        for (const env of this.environments) {
            this.currentEnvironment = env;
            lists[env] = await this.getPackageList(productId);
        }

        this.currentEnvironment = currentEnv;

        return lists;
    }

    async createProduct(productName, description, states) {
        if (!/^[\w\d\-]+$/.test(productName)) {
            throw RangeError('invalid product name');
        }

        const product = Product.create({
            name: productName,
            organization: this,
            description: description,
            states: states,
            objectType: 'Product'
        });

        product.id = crypto.randomUUID();

        product.save();

        return product;
    }

    async getProduct(productId) {
        const product = await Product.findById(productId);

        if (!product) {
            return null;
        }

        if (product.organization.id != this.id) {
            console.warn(`attempt by organization ${organization.name} (${organization.id}) to access foreign product %{product.name} (${product.id})`);

            return null;
        }

        return product;
    }

    async _validateNewPackage(pkg) {
        const dateConflict = await this.collection.findOne({
            objectType: 'Package',
            productId: pkg.productId,
            effectiveDate: pkg.effectiveDate,
            archiveTs: {$exists: false}
        });

        if (dateConflict) {
            throw Error(`an existing package has an effective date of ${pkg.effectiveDate}, choose another date`)
        }
    }

    async createPackage(product, effectiveDate, versionInfo) {
        const pkg = R8Package.fromJson({
            effectiveDate: effectiveDate,
            productId: product.id,
            packageId: crypto.randomUUID(),
            objectType: 'Package',
            terms: {}
        });

        const ratingTerm = pkg.createTerm('expression');
        ratingTerm.dataType = 'Currency';
        pkg.defineTerm('_rating', ratingTerm);

        await this._validateNewPackage(pkg);
        await this.savePackage(pkg, versionInfo);

        pkg.environment = this.currentEnvironmentObject;

        return pkg;
    }

    async clonePackage(packageId, effectiveDate, versionInfo, fromEnvironment) {
        const status = await this.getPackageStatus(packageId);

        if (!status[fromEnvironment].versionId) {
            throw Error(`package ${packageId} has no version available in the ${fromEnvironment} environment`);
        }

        const versionId = status[fromEnvironment].versionId;

        const oldPkg = await this.getPackageVersion(versionId);
        const oldJson = oldPkg.json;

        const newPkg = R8Package.fromJson({
            effectiveDate: effectiveDate,
            productId: oldPkg.productId,
            packageId: crypto.randomUUID(),
            objectType: 'Package',
            terms: oldJson.terms
        });

        await this._validateNewPackage(newPkg);
        await this.savePackage(newPkg, versionInfo);

        newPkg.environment = this.currentEnvironmentObject;

        return newPkg;
    }

    async deletePackage(packageId, versionInfo) {
        const doc = await this._getPackageDoc(packageId);

        if (!doc) {
            throw Error(`{packageId} not found or already deleted`);
        }

        const now = new Date();
        console.log('archiving package version for deletion', doc._id);

        await this.collection.updateOne({_id: doc._id}, {
            $set: {
                archiveTs: now,
                deleted: true,
                versionInfo: versionInfo
            },
        });
    }

    async _getPackageDoc(packageId) {
        try {
            return this.collection.findOne({
                objectType: 'Package',
                packageId: packageId,
                archiveTs: {$exists: false}});
        } catch {
            return null;
        }
    }

    async getPackage(packageId) {
        const doc = await this._getPackageDoc(packageId);

        if (!doc) {
            return null;
        }

        const pkg = R8Package.fromJson(doc);
        pkg.environment = this.currentEnvironmentObject;
        pkg.versionId = doc._id;
        pkg.versionInfo = doc.versionInfo;

        return pkg;
    }

    async getPackageVersion(versionId) {
        const doc = await this.collection.findOne(new ObjectId(versionId));

        if (!doc) {
            return null;
        }

        const pkg = R8Package.fromJson(doc);
        pkg.versionId = doc._id;
        pkg.versionInfo = doc.versionInfo;
        pkg.archiveTs = doc.archiveTs;

        return pkg;
    }

    async savePackage(pkg, versionInfo) {
        console.log('saving package', pkg.packageId, pkg.effectiveDate);
        const now = new Date();

        const doc = await this._getPackageDoc(pkg.packageId);

        if (doc && doc.effectiveDate != pkg.effectiveDate) {
            throw Error(`unable to save package version: effective date {pkg.effectiveDate} does not match {doc.effectiveDate}`);
        }

        if (doc) {
            console.log('archiving package version', doc._id);

            await this.collection.updateOne({_id: doc._id}, {$set: {archiveTs: now}});
        }

        const json = pkg.json;
        if (versionInfo !== undefined) {
            versionInfo.saveTs = now;
            json.versionInfo = versionInfo;
        }

        delete json._id;

        return await this.collection.insertOne(json);
    }

    getCurrentPackage(productId, environment) {
        environment = environment || this.currentEnvironment;

        const status = this.getPackageStatus(productId)
    }

    validateIdentifier(identifier) {
        return Organization.ID_POLICIES[this.idPolicy].test(identifier);
    }

    issueApiToken(issueTo, environment) {
        if (this.environments.indexOf(environment) < 0) {
            throw RangeError(`'${environment}' is not a valid environment (${this.environments.join(', ')})`);
        }

        if (!this.apiTokens) {
            this.apiTokens = {};
        }

        const token = crypto.randomUUID();
        this.apiTokens[token] = {
            issuedTo: issueTo,
            environment: environment
        };

        return token;
    }

    validateApiToken(token, environment) {
        environment = environment || this.currentEnvironment;

        return this.apiTokens[token] && this.apiTokens[token].environment == environment;
    }

    revokeApiToken(token) {
        delete this.apiTokens[token];
    }

    async getChangeLog() {
        const cursor = this.collection.find({'objectType': 'Package'}, {projection: {'effectiveDate': 1, 'versionInfo': 1}})
                .sort({'versionInfo.saveTs': -1});

        let doc;
        const changeLog = [];
        while (doc = await cursor.next()) {
            Object.assign(doc, doc.versionInfo);
            doc.versionId = doc._id;
            delete doc._id;
            delete doc.versionInfo;

            changeLog.push(doc);
        }

        return changeLog;
    }

    async deploy(packageId, deployInfo, fromEnvironment) {
        fromEnvironment = fromEnvironment || this.currentEnvironment;

        const environmentIndex = this.environments.indexOf(fromEnvironment);

        if (environmentIndex < 0) {
            throw new Error(`deploy: bad from environment ${fromEnvironment}`);
        }

        if (environmentIndex >= this.environments.length-1) {
            throw new Error(`no higher environment to deploy to from ${fromEnvironment}`);
        }

        const status = await this.getPackageStatus(packageId);
        const versionId = status[fromEnvironment].versionId;

        const pkg = await this.getPackageVersion(versionId);

        const product = await this.getProduct(pkg.productId);

        const issues = pkg.linter && pkg.linter.getPackageIssues(pkg);

        if (issues && issues.length) {
            throw new Error(`unable to deploy due to the following package issues:\n\t${issues.join('\n\t')}`);
        }

        const nextEnvironment = this.environments[environmentIndex+1];

        console.debug(`${product.name}: deploying package ${pkg.packageId} from ${fromEnvironment} to ${nextEnvironment}`);

        // !!!TBD!!! wsm -- implement business rules here about when it's valid to deploy to production, etc.
        if (pkg.versionId.equals(status[nextEnvironment].versionId)) {
            return;
        }

        Object.assign(deployInfo, {
            objectType: "DeployInfo",
            deployTs: new Date(),
            packageId: pkg.packageId,
            environment: nextEnvironment,
            versionId: pkg.versionId,
            effectiveDate: pkg.effectiveDate
        });

        const resp = await this.collection.insertOne(deployInfo);

        await this.collection.updateMany({
                _id: {'$ne': resp.insertedId},
                objectType: 'DeployInfo',
                packageId: pkg.id,
                environment: nextEnvironment,
                replacedById: {'$exists': false}
            }, {
                '$set': {
                    replacedById: resp.insertedId,
                }
        });
    }

    async getPackageStatus(packageId) {
        const pkg = await this.getPackage(packageId);

        const deployments = this.collection.find({
            objectType: 'DeployInfo',
            packageId: packageId,
            replacedById: {'$exists': false}
        }).sort({deployTs: -1});

        const resp = {
                [this.environments[0]]: {
                    versionId: pkg.versionId,
                    versionInfo: pkg.versionInfo
                }
        };

        for await (const deployInfo of deployments) {
            if (!(deployInfo.environment in resp)) {
                resp[deployInfo.environment] = {
                    versionId: deployInfo.versionId,
                    versionInfo: {
                        userId: deployInfo.userId,
                        deployTs: deployInfo.deployTs
                    }
                }
            }
        }

        this.environments.forEach((env) => {
            if (!(env in resp)) {
                resp[env] = {
                    versionId: null
                }
            }
        });

        return resp;
    }
}

class Product extends R8Document {
    constructor() {
        super();

        this._schema._id = { type: String };
        this.name = String;
        this.organization = Organization;
        this.description = String;
        this.states = Array;
    }
}

class LoginSession extends R8Document {
    constructor() {
        super();

        this._schema._id = { type: String };
        this.user = {
            type: User,
            required: true
        };
        this.confirmSecret = {
            type: String,
            default: crypto.randomUUID
        };
        this.confirmMnemonic = {
            type: String,
            default: () => emojis.random(3)
        };
        this.confirmDateTime = Date;
    }

    get valid() {
        return !!this.confirmDateTime;
    }

    async confirmLogin(confirmSecret) {
        if (this.confirmSecret == confirmSecret) {
            this.confirmDateTime = new Date();
            await this.save();
        }

        return this.valid;
    }
}

class User extends R8Document {
    static MAX_LOGIN_SESSIONS = 5;

    static normalizeEmail(email) {
        return email.trim().toLowerCase();
    }

    constructor() {
        super();

        this._schema._id = { type: String };
        this.organization = Organization;
        this.email = String;
        this.loginSessions = [String];
    }

    get name() {
        return this.email.split('@')[0];
    }

    get defaultEnvironment() {
        // !!!TBD!!! after we implement roles, etc. we can infer this
        return this.organization.environments[0];
    }

    async getProductList() {
        return this.organization.getProductList();
    }

    async getPackageList() {
        return this.organization.getPackageList();
    }

    async preSave() {
        if (this._id === undefined) {
            this.id = User.normalizeEmail(this.email);
        }

        if (this.organization === undefined) {
            this.organization = Organization.create({
                name: `(${this.email})`
            });
            this.organization.id = crypto.randomUUID();
            await this.organization.save();
        }

        if (this.loginSessions.length > User.MAX_LOGIN_SESSIONS) {
            log.warn(`user ${this.id} exceeded ${User.MAX_LOGIN_SESSIONS} logins (${this.loginSessions.length})`);
            while (this.loginSessions.length > User.MAX_LOGIN_SESSIONS) {
                const sessionId = this.loginSessions.shift();
                log.warn(`user ${this.id}: deleting session: ${sessionId}`);

                var session = await LoginSession.findById(sessionId);
                session.delete();
            }
        }
    }

    async initiateLogin(sessionId) {
        let session = await LoginSession.findById(sessionId);

        if (session) {
            log.warn('intiateLogin: session exists', sessionId);

            if  (session.user._id != this._id) {
                throw new SecurityException(`attempt to initiate login for existing user ${session.user.id} session: ${sessionId} by ${this.id}`);
            } else {
                return session;
            }
        }

        if (this.loginSessions.indexOf(sessionId) >= 0) {
            session = await LoginSession.findById(sessionId);

            if (session) {
                return session;
            }
        }

        session = LoginSession.create({
            user: this
        });

        session.id = sessionId;
        await session.save();

        if (this.loginSessions.indexOf(session.id) < 0) {
            this.loginSessions.push(session.id);

            await this.save();
        }

        return session;
    }

    async cancelLogin(loginSessionId) {
        const loginSession = await LoginSession.findById(loginSessionId);
        loginSession && await loginSession.delete();

        this.loginSessions = this.loginSessions.filter(sid => sid != loginSessionId);

        const ws = wsMap.get(loginSessionId);
        if (ws) {
            ws.close();

            wsMap.delete(loginSessionId);
        }

        return await this.save()
    }
}

module.exports = {
    client: client,
    r8: client.db('r8'),
    collection: (name) => client.db('r8').collection(name),
    Organization: Organization,
    Product: Product,
    User: User,
    LoginSession, LoginSession
}
