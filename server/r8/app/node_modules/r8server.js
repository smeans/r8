const path = require('path');
const fs = require('fs');

const sqlite3 = require('sqlite3').verbose();

const config = require('config');

/** Contains all context needed to host and execute an R8Package. */
class R8Environment {
    constructor(organization) {
        if (this.constructor == R8Environment) {
            throw new TypeError('abstract base class R8Environment cannot be instantiated');
        }

        this.organization = organization;
    }

    get fileRoot() {
        const root = path.join(config.org_file_store_root, `${this.organization.id}-${this.organization.currentEnvironment}`);

        if (!fs.existsSync(root)) {
            fs.mkdirSync(root, {recursive: true});
        }

        return root;
    }

    get tableProvider() {
        throw new Error('tableProvider property must be overridden');
    }
}

class R8NodeEnvironment extends R8Environment {
    get tableProvider() {
        if (!this._tableProvider) {
            this._tableProvider = new R8SqliteTableProvider(this);
        }

        return this._tableProvider;
    }
}

/** Abstract class for R8 provider classes. */
class R8Provider {
    constructor(environment) {
        if (this.constructor == R8Provider) {
            throw new TypeError('abstract base class R8Provider cannot be instantiated');
        }

        this.environment = environment;
    }
}

/** Abstract class to represent a R8 table term raw data table. */
class R8Table {
    constructor(provider, term) {
        if (this.constructor == R8Table) {
            throw new TypeError('abstract base class R8Table cannot be instantiated');
        }

        this.provider = provider;
        this.term = term;
    }
}

/**
 *  Abstract class to support R8 table terms.
 *
 *  Table providers must support table maintenance and table value
 *  lookups. They are bound to a R8Environment, which provides
 *  access to system resources like relational databases, file storage,
 *  etc.
 */
class R8TableProvider extends R8Provider {
    constructor(environment) {
        super(environment);

        if (this.constructor == R8TableProvider) {
            throw new TypeError('abstract base class R8TableProvider cannot be instantiated');
        }
    }

    lookupTerm(term) {
        throw new Error('lookupTerm not implemented');
    }

    getTermTable(term) {
        throw new Error('getTermTable not implemented');
    }
}

class R8SqliteTable extends R8Table {
    constructor(provider, term) {
        super(provider, term);

        this._syncTableStructure();
    }

    get db() {
        return this.provider.getPackageDb(this.term.package);
    }

    get table_info() {
        this.db.all(`pragma table_info("${this.term.name}")`, (err, rows) => {
            console.assert(!err);
            return rows;
        });
    }

    _syncTableStructure() {
        if (this.table_info === undefined) {
            this._createTable();
        }
    }

    _createTable() {
        const args = Array.from(this.term.keyTermNames);
        args.unshift(this.term.name);
        const sql = `create table ? (?${', ?'.repeat(args.length-1)})`;
        console.log('sql', sql);
        // !!!TBD!!! pick up here
    }
}

class R8SqliteTableProvider extends R8TableProvider {
    _packageDbs = {};

    lookupTerm(term) {
        const table = this.getTermTable(term);
    }

    getTermTable(term) {
        return new R8SqliteTable(this, term);
    }

    getPackageDb(pkg) {
        const name = pkg.packageName;

        if (!(this._packageDbs[name])) {
            this._packageDbs[name] = new sqlite3.Database(path.join(this.environment.fileRoot, `${name}.sqlite3`));
            this._packageDbs[name].serialize();
        }

        return this._packageDbs[name];
    }
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        R8Environment,
        R8NodeEnvironment
    }
}
