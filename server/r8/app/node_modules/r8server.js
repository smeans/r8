const path = require('path');
const fs = require('fs');

const Database = require('better-sqlite3');

const config = require('config');

/** Contains all context needed to host and execute an R8Package. */
class R8Environment {
    constructor(organization) {
        if (this.constructor == R8Environment) {
            throw new TypeError('abstract base class R8Environment cannot be instantiated');
        }

        this.organization = organization;
    }

    get fileRoot() {
        const root = path.join(config.org_file_store_root, `${this.organization.id}-${this.organization.currentEnvironment}`);

        if (!fs.existsSync(root)) {
            fs.mkdirSync(root, {recursive: true});
        }

        return root;
    }

    get tableProvider() {
        throw new Error('tableProvider property must be overridden');
    }
}

class R8NodeEnvironment extends R8Environment {
    get tableProvider() {
        if (!this._tableProvider) {
            this._tableProvider = new R8SqliteTableProvider(this);
        }

        return this._tableProvider;
    }
}

/** Abstract class for R8 provider classes. */
class R8Provider {
    constructor(environment) {
        if (this.constructor == R8Provider) {
            throw new TypeError('abstract base class R8Provider cannot be instantiated');
        }

        this.environment = environment;
    }
}

/** Abstract class to represent a R8 table term raw data table. */
class R8Table {
    constructor(provider, term) {
        if (this.constructor == R8Table) {
            throw new TypeError('abstract base class R8Table cannot be instantiated');
        }

        this.provider = provider;
        this.term = term;
    }

    get keys() {
        throw "abstract method not implemented";
    }

    query() {
        throw "abstract method not implemented";
    }
}

/**
 *  Abstract class to support R8 table terms.
 *
 *  Table providers must support table maintenance and table value
 *  lookups. They are bound to a R8Environment, which provides
 *  access to system resources like relational databases, file storage,
 *  etc.
 */
class R8TableProvider extends R8Provider {
    constructor(environment) {
        super(environment);

        if (this.constructor == R8TableProvider) {
            throw new TypeError('abstract base class R8TableProvider cannot be instantiated');
        }
    }

    lookupTerm(term) {
        throw new Error('lookupTerm not implemented');
    }

    getTermTable(term) {
        throw new Error('getTermTable not implemented');
    }
}

class R8SqliteTable extends R8Table {
    constructor(provider, term) {
        super(provider, term);

        this._syncTableStructure();
    }

    query(where) {
        where = this._filterColumns(where);

        let sql = `select _id, _value, ${Array.from(this.term.keyTermNames).map(key => `"${key}"`).join(', ')} from ${this.term.name}`;
        console.log('query', sql);
        if (typeof where == 'object') {
            const cols = Object.keys(where);
            sql += ` where ${cols.map(col => `"${col}" == ?`).join(' and ')}`;
        } else {
            where = {};
        }

        try {
            const stmt = this.db.prepare(sql);

            return stmt.iterate(Object.values(where));
        } catch (e) {
            console.warn(e);

            return [];
        }
    }

    insert(values) {
        values = this._filterColumns(values);
        const cols = Object.keys(values);

        const sql = `insert into ${this.term.name} (${cols.map(col => `"${col}"`)}) values (?${', ?'.repeat(cols.length-1)})`;

        try {
            const stmt = this.db.prepare(sql);
            const info = stmt.run(Object.values(values));

            if (info.changes == 1) {
                const rows = Array.from(this.query({_id: info.lastInsertRowid}));

                return rows.length > 0 ? rows[0] : null;
            }
        } catch (e) {
            console.error('table insert', e);
        }

        return null;
    }

    update(where, values) {
        where = this._filterColumns(where);
        values = this._filterColumns(values);

        const whereClause = Object.keys(where).map(key => `"${key}" = ?`).join(' and ');

        const sql = `update ${this.term.name} set ${Object.keys(values).map(key => `"${key}" = ?`).join(', ')} where ${whereClause}`;

        try {
            const stmt = this.db.prepare(sql);
            const parms = Object.values(values).concat(Object.values(where));
            const info = stmt.run(parms);

            return info.changes;
        } catch (e) {
            console.error('table update', e);

            return 0;
        }
    }

    delete(where) {
        where = this._filterColumns(where);

        const whereClause = Object.keys(where).map(key => `"${key}" = ?`).join(' and ');

        const sql = `delete from ${this.term.name} where ${whereClause}`;

        try {
            const stmt = this.db.prepare(sql);
            const info = stmt.run(Object.values(where));

            return info.changes;
        } catch (e) {
            console.error('table delete', e);

            return 0;
        }
    }

    getChoices(col) {
        if (!this.columns.has(col)) {
            console.warn(`non-existent column ${col}`);

            return [];
        }

        const sql = `select distinct ${col} from ${this.term.name};`;
        const stmt = this.db.prepare(sql);

        return stmt.iterate();
    }

    get db() {
        return this.provider.getPackageDb(this.term.package);
    }

    get table_info() {
        const stmt = this.db.prepare(`pragma table_info(${this.term.name})`);
        return stmt.all();
    }

    get columns() {
        return new Set(this.table_info.map(info => info.name));
    }

    _syncTableStructure() {
        try {
            const columns = this.columns;

            if (columns.size <= 0 && this.term.keyTermNames.size > 0) {
                this._createTable();

                return;
            }

            const added = Array.from(this.term.keyTermNames).filter(key => !columns.has(key));
            added.forEach(col => {
                const stmt = this.db.prepare(`alter table ${this.term.name} add column "${col}";`)
                stmt.run();
            });
            const removed = Array.from(columns).filter(col => col[0] != '_' && !this.term.keyTermNames.has(col));
            if (removed.length) {
                console.warn('_syncTableStructure: columns removed', removed);
            }
            // !!!TBD!!! right now, columns can't be deleted. That means if you re-add
            // a key column, the data will still be there.
        } catch (e) {
            console.error('syncTable error', e);
        }
    }

    _createTable() {
        const args = Array.from(this.term.keyTermNames);
        const sql = `create table ${this.term.name} (_id integer primary key, _value, ${args.join(', ')})`;
        console.debug('create table', sql);
        const stmt = this.db.prepare(sql);
        stmt.run();
    }

    _filterColumns(o) {
        const columns = this.columns;

        return o && Object.fromEntries(Object.entries(o).filter(([key, value]) => columns.has(key)));
    }
}

class R8SqliteTableProvider extends R8TableProvider {
    _packageDbs = {};

    lookupTerm(term) {
        const table = this.getTermTable(term);
    }

    getTermTable(term) {
        return new R8SqliteTable(this, term);
    }

    getPackageDb(pkg) {
        const name = pkg.packageName;

        if (!(this._packageDbs[name])) {
            this._packageDbs[name] = new Database(path.join(this.environment.fileRoot, `${name}.sqlite3`), {
                verbose: console.debug
            });
            this._packageDbs[name].serialize();
        }

        return this._packageDbs[name];
    }
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        R8Environment,
        R8NodeEnvironment
    }
}
